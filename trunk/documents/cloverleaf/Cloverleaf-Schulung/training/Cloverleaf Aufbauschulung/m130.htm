<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>



<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 130: Syntactic and Semantic Validation of Message Content</h1>





<h2> Introduction </h2>

The process of validating message content encompasses both 
the process of checking the content using its underlying data structure
and the process of determining whether the content 
is 'acceptable' or 'reasonable' given its context.
These two types of validation are respectively
known as <em>Syntactic</em> and <em>Semantic</em> validation.
<p>
Syntactic validation is equivalent to checking the structure of the data 
at the OSI-presentation layer. 

<PRE>Example: "1998-09-15" is a value formatted according to the type "YYYY-MM-DD", 
         whereas "SEP 09 98" and "xmas-95" aren't.
</PRE>
<p>
Semantic validation is equivalent to checking the value of the data (i.e. its 'meaning') 
in its context at the OSI-application layer.

<PRE>Example: "1998-09-15" is a reasonable date-of-birth in a message, 
         "4102-12-20" probably not.
</PRE>
<p>
Validation should be used only when the destination system
is unable to accept non-validated data. 
The interface software of most message-based systems is quite capable of dealing 
with messages that contain erroneous fields.
Some systems require the validation of (parts of) the message content,
according to their own validation criteria, before the message can be sent by the Integrator.
For such systems, the receipt of an erroneous message
could result in a corrupt database or in 'hanging' the interface software. 
<p>
Being the prudent programmers that we all are (grin), you may want to validate the
entire message content even when it is not required by the destination system. 
Unless we know the exact structure, the types of the fields, its mandatory components and
the semantics of the field/message, we can never be sure that validation
within the Integrator actually serves a useful purpose. We may be validating
a field that is not even used by the destination. For these reasons validation 
should only be used if the destination system explicitly requires it.

<h2> Validation Methods </h2>

Within the Integrator the validation process can be achieved by using the following methods:
<UL>
<LI>Syntactic validation by using the record type definition.
Integrator supports two types of syntactic validation executed at different
points in the message flow. The syntactic validation types are:
   <UL>
   <LI>Parse <br>
       Validates the message when it is parsed 
       (broken apart for use in the translation system). 
       This option forces validation of all message components
       even when they are not used during the translation process.
    <LI>Fetch <br>
       Validates a message component whenever the data definition is fetched
       or used for an input or output operation. Fetch validation
       is limited to message components that are used during the translation process.
    </UL>
<LI>Semantic (and Syntactic) validation in Tcl procedures. <br>
    Semantic validation and non-standard syntactic validation can be achived
    by using Tcl procedures.
    Semantic validation is typically executed in Code Fragment (xltp) Tcl procedures.
    If a validation error is detected, the message can be optionally placed
    in the error database.
</UL> 

<h2>1. Syntactic Validation based on the Record Type definition </h2> 
The basis for syntactic validation
is the definition of the record type of the message. 
Integrator currently supports the following standard record types: FRL, VRL, HRL, HL7, X12, EDIFACT and SWIFT.
Most record type definitions allow
for the specification of mandatory message components and support typed message components.
The mandatory message components as well as the types of its field can be specified using
the Integrator GUI.

<UL>
<LI><b>FRL</b><BR>
    The FRL record type supports typed fields as well as mandatory fields.
    FRL and VRL are the only data formats that allow for Parse validation as 
    well as Fetch validation.
    The FRL record type supports verification of the existence and format at the subfield level.
    <br>
    The validation options for FRLs/VRLs are:
    <UL>
    <LI>None <br>
       No validation.
    <LI>Exist <br>
       Validate the existence of the data, but not its existence.
       The field has to contain some value.
    <LI>Content <br>
       Validate the type of data, but not its existence.
       The content of the subfield (if it exists) has to match the type of the
       subfield. e.g. a date of type YYYYMMDD should not contain characters.
    <LI>Exist + Content <br>
       Validate both the existence and the contents of the data.
       The content of the subfield (which has to exist) has to match the type of the
       subfield.    
    </UL>
    Validation will also be performed when encoding the message after the translation process.
<LI><b>VRL</b><BR>
    The VRL record type supports typed elements as well as mandatory elements.
    VRL and FRL are the only data formats that allow for Parse validation as 
    well as Fetch validation.
    The VRL record type supports verification of the existence and format at the 
    field level, the subfield level and the subsubfield level.
    <br>
    See FRL for a description of the validation options.   
<LI><b>HRL</b><BR>
    An HRL record type is defined in terms in terms of FRLs and VRLs (HRLs can be nested,
    but the atomic parts have to be either FRL or VRL). The validation options are therefore
    the same as those supported by FRL and VRL.
<LI><b>HL7, X12, EDIFACT, SWIFT</b><BR>
    These record types supports typed fields as well as
    required message components (segments, blocks, groups of segments, composite data elements, fields).
    These formats support Fetch validation.  
    Validation will also be performed when encoding the message after the translation process.
</UL>

<h2>Xlate Error Action</h2>

Standard validation in the Integrator is executed by the translation thread.
The error action option in the translation specification GUI specifies 
how to handle any
errors (including validation errors) that occur during the translation process. 
The following options
are available for error handling:
<UL>
<LI><b>Skip</b><br> Skips this translation action if an error occurs, and continues
with the rest of the translation.
<LI><b>Pad</b><br> Pads the output values with the fill character if an error occurs,
and continues with the rest of the translation.
<LI><b>Error</b><br> Aborts this translation and reports the error.
</UL>

<b> Example of standard validation </b> <br>
The following is an example of the validation error handling when copying a constant
value to a timestamp is a field in a FRL defined as YYMMDDHHMMSS+Z:

<PRE>COPY =aaaaa -> timestamp</PRE>

<UL>
<LI>FRL Field validation = <b>Parse</b> <br>
    When the FRL subfield validation is set to Content (or Exist+Content) and
      Xlate error handling is set to Skip or Error, the translation thread
      generates an error during the execution of the translation specification.   
      The translation will be aborted and the message is stored in the error database. 
<LI>FRL Field validation = <b>Fetch</b> <br>
    When the FRL subfield validation is set to Content (or Exist+Content) and
      Xlate error handling is set to Skip, the translation thread
      generates an warning during the execution of the translation specification.    
      The translation will not be aborted.
    <br>
    When the FRL subfield validation is set to Content (or Exist+Content) and
      Xlate error handling is set to Error, the translation thread
      generates an error during the execution of the translation specification. 
      The translation will be aborted and the message is stored in the error database.
</UL>
Record types other than FRL, VRL and HRL support Fetch validation only. A message
that fails the validation will be stored in the error database <b>only if</b>
the error control for the translation action is set to <b>error</b>.
Use hcidbdump to periodically check the error database for messages that could not
be validated.

<h2>2. Explicit Syntactic/Semantic validation using Tcl </h2>

Semantic validation (or non-standard syntactic validation)
is typically executed in Code Fragment (xltp) Tcl procedures.
Code Fragment procedures (Pre-Proc, CALL, Post-Proc) can be used in the translation 
thread to manipulate/validate one or more fields. Once a validation error
is detected the message can be optionally put in the error database.
<p>
Syntactic validation of mandatory message components can be executed in a TPS Tcl procedure.
If a validation error occurs, an error description can be stored in the
USERDATA metadata field and the message can be forwarded to the error database
using an ERROR disposition. If a validation error occurs the message can be
routed to an alternative thread instead of storing it in the error database.
<p>
If messages with validation errors are stored in the error database (by means
of the ERROR disposition or by using xpmerror) the error database should be
periodically checked for messages that could not be validated.

<h2>2.1 TPS Style Validation Procedures</h2>

Whereas Code Fragment Tcl procedures are typically used to deal with individual
fields (or other message elements)
TPS procedures are typically used to manipulate the entire message. 
TPS validation procedures (IB TPS) check the basic structure of the inbound
message. Possible validation methods include:
<UL>
<LI>Using the standard grmcreate procedure to see whether the message can
be parsed using a record type definition or not;
<LI>Parsing the message by means of string manipulation.
</UL>

<p>
The standard functions <b>grmcreate, grmreset</b> parse the message.
If the record type specifies any parse time validation (FRL,VRL and HRL)
then the validation option of these procedures returns any errors 
when validating those parts of the message for which parse time
validation was specified.

<PRE>grmcreate -msg $mh -warn w frl myfrl.frl ; echo $w
{TimeStamp: not valid ts data}{NumberField: not valid ai data}
</PRE>

<!-----------------------------
# 100 % OK message
set mh [msgcreate {UNH+3007+MEDDIE:P:95B:RK:R98002'BGM+DIE+3007+1+ERR'DTM+97:199808241004:203'NAD+PO+100300++Andersen:Poul Arne::::SG'ADR+WO:PO+1:Rose Lane:27+Bopulu+12 FX+SK'RFF+TN:3007'PNA+PAT+923612444:SSN++OF++SU:Holmann+FO:Hermann+IN:H.A.'ADR+HO:PH+1:Hollow Blvd:123+Bopulu+14 GH+SK'RFF+BL:A NEG'RFF+SX:M'RFF+DOB+285:199700801:102'RFF+LOC:613'RFF+MS:S'SFD+82365:SFC:RKK:Mashed Potatoes+500+GRM'SFD+00421:SFC:RKK'SFD+82625:SFC:RKK'FTX+DES+++Pre-operative low sodium'DTM+286:19980824:102'UNT+35+3007'}]

# remove mandatory segment NAD
set mh [msgcreate {UNH+3007+MEDDIE:P:95B:RK:R98002'BGM+DIE+3007+1+ERR'DTM+97:199808241004:203'ADR+WO:PO+1:Rose Lane:27+Bopulu+12 FX+SK'RFF+TN:3007'PNA+PAT+923612444:SSN++OF++SU:Holmann+FO:Hermann+IN:H.A.'ADR+HO:PH+1:Hollow Blvd:123+Bopulu+14 GH+SK'RFF+BL:A NEG'RFF+SX:M'RFF+DOB+285:199700801:102'RFF+LOC:613'RFF+MS:S'SFD+82365:SFC:RKK:Mashed Potatoes+500+GRM'SFD+00421:SFC:RKK'SFD+82625:SFC:RKK'FTX+DES+++Pre-operative low sodium'DTM+286:19980824:102'UNT+35+3007'}]

echo [msgget $mh]

# message type has to be specified - grmencode won't work without it
if [catch {set gh [grmcreate -msg $mh -warn w edifact 95B his_jka MEDDIE]}] { echo ZZZ }
# Warning contains Parse validation errors only, edi doesn't support parse validation
echo $w

# The parsing error is *printed* to stdoud/stderr, it's no warning or error ! PR !
if [catch {set mh2 [grmencode -warn w $gh]} enc_err] {
    # Oops. Error during encode, most likely due to syntactic error
    echo Encoding errors: $enc_err
} 
echo $w


grmdestroy $gh
msgdestroy $mh
------------------------------->

<!----------------------------
<h2>Examples</h2>


<PRE>             XXXXXXXXXXX TPS PROC Example
</PRE>
------------------------------>

<h2>2.2 Code Fragment Validation Procedures</h2>

A code fragment Tcl procedure allows for the manipulation of fields involved
in a translation action. 

<p>
The xpmerror function can be used to generate an error condition in the XPM if
the Code Fragment validation procedure detects a validation error.
When you generate an XPM error, the severity of the error can be specified as follows:
<UL>
<LI>action: The error is handled as specified by the XLT statement control value (Skip/Pad/Error)
 specified in the translation configurator.
<LI>curdetail: Error out the current translation routing details, but continue
the remaining ones.
<LI>alldetail: Error out all of the message's translation routing details.
</UL>
<p>

<h2>Examples</h2>

The procedure <em>validateLength</em> shown below can be used to explicitly validate
the length of a field. Note that the severity parameter of xpmerror is set to <em>action</em>:
the handling of the error (Pad/Skip/Error) can be specified in the Xlate GUI.


<PRE>##########################################################
# Name:  validateLength
# Type:  xltp (Pre-Procedure)
# Args:  n (the mandatory length of [lindex $xlatInVals 0])
#        If the length of the field could not be validated
#        then xpmerror is used with severity action. 
#
proc validateLength { n } {
    upvar xlateId       xlateId        \
          xlateInVals   xlateInVals    \
          xlateInList   xlateInList    \
          xlateOutVals  xlateOutVals     
   
    set value [lindex $xlateInVals 0]
    if {[clength $value] != $n} {
       set field [lindex $xlateInList 0]
       set errMsg "(ValidateLength) Length of $field \
		 ([clength $value]) unequal to $n"
       catch [ xpmerror $xlateId action $errMsg ]
    }
}
</PRE>

The procedure <em>useAlternativeValue</em> uses xpmfetch to retrieve
the fetch time syntactic validation errors detected by the engine. If there
are any validation values, an alternative value will be stored in the
destination field. 


<PRE>xpmfetch -warn w $gh myfield ; echo $w
{myfield: not valid ai data}
</PRE>


<PRE>##########################################################
# Name:  useAlternativeValue
# Type:  xltp (Pre-Procedure)
# Args:  None.
#
proc useAlternativeValue {} {
    upvar xlateId       xlateId        \
          xlateInList   xlateInList    \
          xlateInVals   xlateInVals    \
          xlateOutVals  xlateOutVals
  
    lassign $xlateInVals inval altval
    set dhList [ xpmfetch -warn w $xlateId [lindex $xlateInList 0]]
    datdestroy -list $dhList
    if [clength $w] {
       # fetch time validation warnings exist; use alternative value
       lvarpop xlateOutVals 0 $altval
    }   
}
</PRE>  

The procedure <em>validateUsingTable</em> validates the value
of a field using a table. This procedure is used for semantic validation.
Note that the severity parameter of xpmerror is set to <em>action</em>:
the handling of the error (Pad/Skip/Error) can be specified in the Xlate GUI.


<PRE>##########################################################
# Name:  validateUsingTable
# Type:  xltp (Pre-Procedure)
# Args:  table   The name of the table used to validate
#                [lindex $xlatInVals 0].
#        errMsg  The error message to be supplied to
#                xpmerror. A default description will be
#                used when this parameter is omitted.
#
proc validateUsingTable { table  { errMsg {}} } {
    upvar xlateId       xlateId        \
          xlateInList   xlateInList    \
          xlateInVals   xlateInVals 
  
    set inval [lindex $xlateInVals 0]
    set outval [tbllookup $table $inval]
    if {![clength $outval]} {
       # construct default err message if errMsg param not set
       if {![clength $errMsg]} { 
          set field [lindex $xlateInList 0]
          set errMsg "(validateUsingTable) The value of field $field ($inval) \
		was not found in table $table."
       }
       catch [ xpmerror $xpmId action $errMsg ]
    }    
}
</PRE>  

<p>
Copyright 1998,2001 LifeLine Europe/Healthcare.com
</BODY>
</HTML>
