<HTML>
<HEAD>
	<TITLE>Integrator Level II+ Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>



<h1>
<img src="images/hie_box.gif" align="middle" hspace=7>
 Integrator - ODBC Training </H1>

<h1> Module 210: Initializing and Terminating an ODBC Connection </h1>





This module covers the initialization and termination of ODBC connections.  
A number of control structures and handles have to be
created before an ODBC connection can be established. 
This module also covers the return codes returned by the various ODBC procedures.

<h1> Handling Return codes and Failures </h1>

Most functions within the ODBC API return a result code. 
Odbc procedures are generally called in the following manner: <br>
<b>set rc [ odbc SQL<em>function_name</em> &nbsp; <em>parameters</em> ] </b>.

<p>
The Tcl implementation
of the API returns one of the following strings as the return code:

<TABLE BORDER="1" WIDTH=630>
<TR><TD valign="top">SQL_SUCCESS</TD><TD>The function executed successfully. 
    There is no error information to return. </TD></TR>
<TR><TD valign="top">SQL_SUCCESS_WITH_INFO<TD>The function executed successfully, 
    however there is some information available. This is much like a warning.</TD></TR>
<TR><TD valign="top">SQL_NO_DATA_FOUND<TD>All the rows of a result set have been fetched. This is not
    an error, it specifies that there is no more information left to retrieve. </TD></TR>
<TR><TD valign="top">SQL_ERROR<TD> The function failed to execute, and there is additional 
    error information to retrieve. </TD></TR>
<TR><TD valign="top">SQL_INVALID_HANDLE<TD> Handles are used in ODBC to represent environments, connections,
    and statements. This error is returned when one or more handles
    used by a procedure are not valid.</TD></TR>
<TR><TD valign="top">SQL_STILL_EXECUTING<TD> A function executed asynchronously and still is executing. 
    The return code has to be unequal to STILL_EXECUTING before the result set can be fetched.</TD></TR>
<TR><TD valign="top">SQL_NEED_DATA<TD> When preparing or executing a statement, the driver determined that
    the application must specify one or more parameter values. Likely cause: the number of
    bound parameters is different from the number of parameter markers in the SQL statement.</TD></TR>
</TABLE>

The list below contains a description and the usage of some of the ODBC functions.
The flag that preceeds the procedure name (**,* or --) indicates
the frequency of use of the procedure (frequently, regularly, almost never)
and hence its importance.

<P>
<TABLE>
<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLError henv hdbc hstmt SqlStateVarName NativeErrorVarName ErrorMsgVarName ErrorMsgMax </b><br>
   Purpose: This function returns error or status information.
            The <em>ErrorMsg</em> is an ODBC specific textual description of the error
            encountered, whereas <em>SqlState</em> is a unique 5 character, ODBC specific identification
            of the error. The <em>NativeError</em> is a description of the error created by
            the data source or the driver (i.e. the Sybase/DB2/.. error description).<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>henv</TD><TD>input</TD><TD>Environment handle or SQL_NULL_HENV
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle or SQL_NULL_HDBC
            <TR><TD>hstmt</TD><TD>input</TD><TD>Statement handle or SQL_NULL_HSTMT
            <TR><TD>SqlStateVarName</TD><TD>output</TD>Identification of the error (ODBC-defined)<TD>
            <TR><TD>NativeErrorVarName</TD><TD>output</TD>Description of the error (data source)<TD>
            <TR><TD>ErrorMsgVarName</TD><TD>output</TD>Description of the error (ODBC-defined)<TD>
            <TR><TD>ErrorMsgMax</TD><TD>input</TD>Max length of the to be returned ErrorMsg string <TD>
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA_FOUND, 
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: To be used to retrieve additional information when the return code
          of an ODBC procedure is SQL_ERROR or SQL_SUCCESS_WITH_INFO.<BR>
   Examples:

<PRE># catch omitted
odbc SQLError $henv $hdbc $hstmt state errcode errmsg 200 msglen
echo Error details: $errmsg ($state , $errcode)
--
proc odbcGetError { henv hdbc hstmt } {
	odbc SQLError $henv $hdbc $hstmt state local msg 200 sz

        # Note that state,local and msg may be empty, particularly
        # when SQLError is called after a previous ODBC procedure
        # returned SQL_SUCCESS

	return [list $state $local $msg]
}
</PRE>
See also the <a href="m210v2.htm">Examples of result code procedures</a>.
</TD><TR>

</TABLE>


<h1> Initializing a connection </h1>

The ODBC environment needed in order to establish a connection
consists of 2 control structures, accessable via their handles:
<UL>
<LI><b>Environment handle</b> <br>
    Provides access to a structure that contains generic static and run time
    information related to ODBC. 
<LI><b>Connection handle</b> <br>
    Provides access to a sructure that contains static and run time information
    related to a particular connection. 
</UL>
A single environment handle may be used by multiple connections. Each connection handle is
associated with exactly one connection. 
The connection can be established once the required control structures have been created.
<br>
See also the <a href="m210v.htm">example TPS and XLTP odbc initialization procedures</a>.
<p>
The list below contains a description and the usage of some of the ODBC functions.
The flag that preceeds the procedure name (**,* or --) indicates
the frequency of use of the procedure (frequently, regularly, almost never)
and hence its importance.
<P>
<TABLE>
<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLAllocHandle handleType inputHandle outputHandle </b>(ODBC 3.x+)<br>
   Purpose: This function allocates memory for an environment/connection handle. <BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>handleType</TD><TD>input</TD><TD>Type of handle, either SQL_HANDLE_ENV (environment),
                                        SQL_HANDLE_DBC (connection), SQL_HANDLE_STMT (statement) 
                                        or SQL_HANDLE_DESC (descriptor).
            <TR><TD>inputHandle</TD><TD>input</TD><TD>Specifies an existing handle in whose context
                             the new handle is to be created. Set to SQL_NULL_HANDLE if allocating
                             an environment handle.
            <TR><TD>outputHandle</TD><TD>output</TD><TD>Variable name containing the resulting handle.
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_INVALID_HANDLE or SQL_ERROR.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: SQLError can't be used in case of failure during the allocation of an environment
          handle since SQLError requires a valid environment handle. <BR>
   Examples:

<PRE># catch omitted
set rc [odbc SQLAllocHandle SQL_HANDLE_ENV SQL_NULL_HANDLE henv]
if $rc .........
set rc [odbc SQLAllocHandle SQL_HANDLE_DBC $henv hdbc]
if $rc .........
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLAllocEnv henvVarName </b>(ODBC 2.0 Only)<br>
   Purpose: This function allocates memory for an environment handle and initializes the
            ODBC call-level interface for use by an application. <BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>henvVarName</TD><TD>output</TD><TD>Environment handle
            </TABLE>
   Return codes: SQL_SUCCESS or SQL_ERROR.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: An application must call SQLAllocEnv before calling any other ODBC function.
          SQLError can't be used in case of failure since SQLError requires a valid
          environment handle. <BR>
   Examples:

<PRE># catch omitted
set rc [odbc SQLAllocEnv henv]
if [cequal $rc SQL_ERROR] {
  echo Error allocating memory for environment handle
} else {
  echo Successfully allocated environment, environment handle = $henv
}
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLAllocConnect henv hdbcVarName </b>(ODBC 2.0 Only)<br>
   Purpose: This function allocates memory for a connection handle within the environment
            indicated by the <em>henv</em> parameter.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>henv</TD><TD>input</TD><TD>Environment handle
            <TR><TD>hdbcVarName</TD><TD>output</TD><TD>Connection handle or SQL_NULL_HDBC
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: Mostly used in combination with SQLAllocEnv.<BR>
   Examples:

<PRE># catch omitted. $henv is assumed to be an environment handle
set rc [odbc SQLAllocConnect $henv hdbc]
if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
  echo Connection handle successfully allocated
} else {
  echo Error ($rc): the connection handle couldn't be allocated
  # if an SQL_ERROR occurred, more info can be requested
  if [cequal $rc SQL_ERROR] {
    set rc [odbc SQLError $henv SQL_NULL_HDBC SQL_NULL_HSTMT \
            state local msg 200 msglen]
    if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
       echo Error details: $msg (state= $state, native error= $local)
    } else {
       echo Error calling SQLError, no further error details available
    }
  }
}
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLConnect hdbc dsn SQL_NTS uid SQL_NTS authStr SQL_NTS </b><br>
   Purpose: This function loads a database driver and establishes a connection to a data source.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle or SQL_NULL_HDBC
            <TR><TD>dsn</TD><TD>input</TD><TD>Data source name (database name), as configured in the driver manager.
            <TR><TD>uid</TD><TD>input</TD><TD>User identifier (login name)
            <TR><TD>authStr</TD><TD>input</TD><TD>Authentication string (password)
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: Although there are many ODBC functions to establish connections; this is the
          only one supported by all drivers. Some data sources (BTrieve, dBase)
          don't require an uid/authorization string.<BR>
   Examples:

<PRE># catch omitted. $henv and $hdbc are assumed to be valid handles.
set dsn "kondor" ;# name as defined in the ODBC driver manager (odbc.ini)
set rc [odbc SQLConnect $hdbc $dsn SQL_NTS "Johnson" SQL_NTS "password" SQL_NTS]
if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
  echo Connection established
} else {
  echo Error ($rc): connection couldn't be established
  # if an SQL_ERROR occurred, more info can be requested
  if [cequal $rc SQL_ERROR] {
    set rc [odbc SQLError $henv $hdbc SQL_NULL_HSTMT \
            state local msg 200 msglen]
    if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
       echo Error details: $msg (state= $state, native error= $local)
    } else {
       echo Error calling SQLError, no further error details available
    }
  }
}
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
- </TD><TD><b>odbc SQLDriverConnect .... </b><br>
   Purpose: This function connects to a data source using a <em>connection string</em>
            allowing you to specify connection attributes using a text format.
            This is an extended ODBC function and is not supported by all drivers.<BR>
   Notes:  SQL_DRIVER_PROMPT is the only value supported by the Tcl API for
           the driverCompletion parameter.
           See other documentation. <br>
   Examples:

<PRE>odbc SQLDriverConnect $hdbc {} "DSN=ibis;UID=Johnson;PWD=secret" \
       SQL_NTS ConnStrOut 255 ConnStrOutLen SQL_DRIVER_NOPROMPT
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
* </TD><TD><b>odbc SQLGetFunctions hdbc function existsVarName </b><br>
   Purpose: This function reports whether a driver supports a particular ODBC function.
            Alternatively, use SQL_API_ALL_FUNCTIONS to get a report for all functions.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle
            <TR><TD>function</TD><TD>input</TD><TD>Identifier of function to test support for
            <TR><TD>existsVarName</TD><TD>output</TD><TD>Function result 
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: Often used to test for the availability of the SQLGetInfo procedure.<BR>
   Examples:

<PRE>proc odbcFunctionSupported { hdbc procname } {
set procname [string toupper $procname]
set procname "SQL_API_$procname"
set rc [SQLGetFunctions $hdbc $procname supportedFlag]
# assuming no error occured..
# $supportedFlag is equal to either TRUE or FALSE
return [cequal $supportedFlag TRUE]
}
# assuming hdbc is a connection handle
echo Procedure supported: [odbcFunctionSupported $hdbc "SQLGetInfo"]  
--
set rc [SQLGetFunctions $hdbc SQL_API_ALL_FUNCTIONS funcs]
echo $funcs ;# contains a keyed list of all functions
# >> {SQL_API_SQLALLOCCONNECT TRUE} {SQL_API_SQLALLOCENV TRUE} ...
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
* </TD><TD><b>odbc SQLGetInfo hdbc infoType infoVarName infoMaxLen infoLenVarName </b><br>
   Purpose: This function returns an item of information regarding the driver
             or data source associated with a connection handle.
            This is a powerful function that is capable of retrieving a wide range of 
            information. The type of information returned depends entirey on the
            value of the infoType parameter.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle
            <TR><TD>infoType</TD><TD>input</TD><TD>Type of information
            <TR><TD>infoVarName</TD><TD>output</TD><TD>Result of the query
            <TR><TD>infoMaxLen</TD><TD>input</TD><TD>Max length of the to be returned query result
            <TR><TD>infoLenVarName</TD><TD>output</TD><TD>Actual length of the query result
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA_FOUND, 
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: infoTypes include:
          <TABLE BORDER=1 WIDTH=600>
          <TR><TD>SQL_ACTIVE_STATEMENTS</TD><TD>Max number of statement handles supported per connection. 0 indicates unlimited/unknown.</TD></TR>
          <TR><TD>SQL_DATA_SOURCE_READ_ONLY</TD><TD>'Y' or 'N' </TD></TR>
          <TR><TD>SQL_DBMS_NAME</TD><TD>Actual DBMS Name, e.g. 'SQL Server' </TD></TR>
          <TR><TD>SQL_MAX_COLUMN_NAME_LEN</TD><TD>The maximum length of column names supported by the data source </TD></TR>
          <TR><TD>SQL_ODBC_VER</TD><TD>The ODBC version of the driver.</TR> 
          </TABLE><BR>
   Examples:

<PRE>set infoType SQL_DBMS_NAME  ;# to retrieve the actual DBMS name
set rc [odbc SQLGetInfo $hdbc $infoType info 255 infolen]
# assuming no errors occurred
echo Information returned about $infoType: $info
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
- </TD><TD><b>odbc SQLDataSources henv direction dsnVarName dsnMax dsnMaxVarName 
                                  descrVarName descrMax descrMaxVarName </b><br>
   Purpose: This function enumerates data source names. It queries the driver
            manager for data related to data sources.<BR>
   Notes: See other documentation.
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
- </TD><TD><b>odbc SQLDrivers ..... </b><br>
   Purpose: This function enumerates the available drivers. It queries the driver
            manager for data related to drivers.<BR>
   Notes: See other documentation.
</TD><TR>


<TR><TD bgcolor=#999999 valign="top">
- </TD><TD><b>odbc SQLSetConnectOption hdbc option paramValue </b>(ODBC 2.0 Only)<br>
   Purpose: This function allows an application to set connection attributes.
            There is no way at run-time to determine what options a driver defined;
            see the driver's documentation.
            This is an extended ODBC function and is not supported by all drivers.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle
            <TR><TD>option</TD><TD>input</TD><TD>The option to set
            <TR><TD>paramValue</TD><TD>input</TD><TD>The value of the option
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: Use SQLGetFunctions to check whether the driver supports this procedure.
          <br>
Examples:

<PRE># catch omitted; hdbc assumed to be a connection handle
odbc SQLSetConnectOption $hdbc SQL_LOGIN_TIMEOUT 30
# (obviously this has to be done before actually connecting)
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
- </TD><TD><b>odbc SQLGetConnectOption hdbc option paramVarName </b>(ODBC 2.0 Only)<br>
   Purpose: This function allows an application to query connection attributes.
            There is no way at run-time to determine what options a driver defined;
            see the driver's documentation.
            This is an extended ODBC function and is not supported by all drivers.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle
            <TR><TD>option</TD><TD>input</TD><TD>The option to set
            <TR><TD>paramVarName</TD><TD>output</TD><TD>The value of the option
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: Use SQLGetFunctions to check whether the driver supports this procedure.
          <br>
Examples:

<PRE># catch omitted; hdbc assumed to be a connection handle
odbc SQLGetConnectOption $hdbc SQL_LOGIN_TIMEOUT timeOut
echo "Timeout for login is currently set to $timeOut seconds."
</PRE>
</TD><TR>

</TABLE>


<h1> Terminating a connection </h1>

The termination of a connection can be accomplished by
disconnecting from the data source and destroying the control structures used
by ODBC.

<p>
The list below contains a description and the usage of some of the ODBC functions.
The flag that preceeds the procedure name (**,* or --) indicates
the frequency of use of the procedure (frequently, regularly, almost never)
and hence its importance.

<P>
<TABLE>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLDisconnect hdbc</b><br>
   Purpose: This function closes out the connection to a data source associated with 
            a specific connection handle.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, 
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: Free any statement handles associated with the connection before
          disconnecting from a datasource.<BR>
   Examples:

<PRE># catch omitted. $hdbc is assumed to a valid handle.
set rc [odbc SQLDisconnect $hdbc]
if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
  echo Successfully disconnected
} else {
  echo Error ($rc): unable to disconnect
  # if an SQL_ERROR occurred, more info can be requested
  if [cequal $rc SQL_ERROR] {
    set rc [odbc SQLError $henv $hdbc SQL_NULL_HSTMT \
                          state local msg 200 msglen]
    if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
       echo Error details: $msg (state= $state, native error= $local)
    } else {
       echo Error calling SQLError, no further error details available
    }
  }
}
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLFreeHandle handleType handle </b>(ODBC 3.0+)<br>
   Purpose: This function releases an environment, connection, statement or
            description handle and frees all memory that is 
            associated with the handle.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>handleType</TD><TD>input</TD><TD>Type of handle, either SQL_HANDLE_ENV (environment),
                                        SQL_HANDLE_DBC (connection), SQL_HANDLE_STMT (statement) 
                                        or SQL_HANDLE_DESC (descriptor).
            <TR><TD>handle</TD><TD>input</TD><TD>Environment, connection, statement or descriptor handle
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: This is the ODBC 3.x equivalent of SQLFreeConnect, SQLFreeEnv and SQLFreeStmt <BR>
   Examples:

<PRE># catch omitted. assuming $hdbc is a connection handle
set rc [odbc SQLFreeHandle SQL_HANDLE_DBC $hdbc]
if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
  echo connection handle freed successfully
} else {
  echo Error ($rc): the connection handle couldn't be freed
  # if an SQL_ERROR occurred, more info can be requested
  if [cequal $rc SQL_ERROR] {
    set rc [odbc SQLError SQL_NULL_HENV $hdbc SQL_NULL_HSTMT \
                          state local msg 200 msglen]
    if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
       echo Error details: $msg (state= $state, native error= $local)
    } else {
       echo Error calling SQLError, no further error details available
    }
  }
}
# catch omitted. assuming $henv is an environment handle
set rc [odbc SQLFreeHandle SQL_HANDLE_ENV $henv]
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLFreeConnect hdbc </b>(ODBC 2.0 Only)<br>
   Purpose: This function releases a connection handle and frees all memory that is 
            associated with the handle.<BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>hdbc</TD><TD>input</TD><TD>Connection handle
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: <BR>
   Examples:

<PRE># catch omitted. assuming $hdbc is a connection handle
set rc [odbc SQLFreeConnect $hdbc]
if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
  echo connection handle freed successfully
} else {
  echo Error ($rc): the connection handle couldn't be freed
  # if an SQL_ERROR occurred, more info can be requested
  if [cequal $rc SQL_ERROR] {
    set rc [odbc SQLError SQL_NULL_HENV $hdbc SQL_NULL_HSTMT \
                          state local msg 200 msglen]
    if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
       echo Error details: $msg (state= $state, native error= $local)
    } else {
       echo Error calling SQLError, no further error details available
    }
  }
}
</PRE>
</TD><TR>

<TR><TD bgcolor=#999999 valign="top">
** </TD><TD><b>odbc SQLFreeEnv henv </b>(ODBC 2.0 Only)<br>
   Purpose: This function frees the environment handle and releases all memory
            associated with the environment handle. <BR>
            <TABLE BORDER="1" WIDTH=600>
            <TR><TD>henv</TD><TD>input</TD><TD>Environment handle 
            </TABLE>
   Return codes: SQL_SUCCESS, SQL_SUCCESS_WITH_INFO,  
                 SQL_ERROR, SQL_INVALID_HANDLE.
                 Note that this Tcl procedure may return a TCL_ERROR if a severe
                 error occurs in the Tcl extension layer unrelated to ODBC. <br>
   Notes: <BR>
   Examples:

<PRE># catch omitted. assuming $henv is an environment handle
set rc [odbc SQLFreeEnv $henv]
if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
  echo environment freed successfully
} else {
  echo Error ($rc): the environment couldn't be freed
  # if an SQL_ERROR occurred, more info can be requested
  if [cequal $rc SQL_ERROR] {
    set rc [odbc SQLError $henv SQL_NULL_HDBC SQL_NULL_HSTMT \
                          state local msg 200 msglen]
    if {[lsearch $rc {SQL_SUCCESS SQL_SUCCESS_WITH_INFO}] >=0} {
       echo Error details: $msg (state= $state, native error= $local)
    } else {
       echo Error calling SQLError, no further error details available
    }
  }
}
</PRE>
</TD><TR>

</TABLE>

<p>
Copyright 1998 HIE Europe
</BODY>
</HTML>
