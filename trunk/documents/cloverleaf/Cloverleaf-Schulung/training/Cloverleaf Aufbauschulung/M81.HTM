<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>


<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 81: PDL: Phrase Definitions</h1>




This module specifies the syntax and semantics necessary to define the phrases
of the driver.
Phrases are the basic mechanisms that define the communication elements over the device;
i.e. they describe the message structure at the OSI session level. 
A phrase defines the nouns and verbs that make up a protocol language;
including delimiter characters (such as &lt;stx&gt;
or &lt;etx&gt;), data fields (both fixed length and variable)
and special fields (checksums, length-encoding).
Phrases structure read and write operations, and define how to separate the protocol's
control characters from the data part of a message.

<p>
The basic syntax of a phrase definition is:

<PRE>define phrase phrase-name;
 phrase-definition-parts;
end phrase;
</PRE>

A phrase represents a way to interpret input, and a framework in 
which to generate output.
A phrase is a hierarchical construction of phrase parts with literal text
or character classes at the leaves. 
Phrases are interpreted as a linear arrangement of characters and fields 
corresponing with the linear-byte stream nature of the serial protocols 
(TCP/IP, RS232) supported by the operating system.

<p>
If checksums
or length encoding has been defined within the phrase definition,
the field will be automatically calculated by the protocol driver
prior to transmitting the msg. For the calculation of non-standard
checksums: see <a href="m85.htm">Module 85: Customized PDLs</a>




<h2>Phrase constant parts</h2>


<PRE>define phrase ack;
 &lt;ack&gt;;
end phrase;

define phrase logon-phrase;
 &lt;stx&gt;;
 "LOGON 3124";
 'a';
 &lt;etx&gt;;
end phrase;
</PRE>

Phrase constants are written with literal characters, strings, named characters or
character classes. Character classes are phrase constant parts that can match one
of several different characters on input. 
<p>
Examples:
'X' matches the character X in the input or will generate an X on output; "XYZ" 
is the quivalent of 'X'; 'Y'; 'Z'; &lt;ack&gt; matches the ASCII value 6. 
<p>
<center>
<TABLE BORDER="1">
<TR><TD>&lt;nul&gt;</TD><TD> 0</TD>     <TD>&lt;bs&gt;</TD><TD>8</TD>
    <TD>&lt;dle&gt;</TD><TD> 16</TD>    <TD>&lt;can&gt;</TD><TD>24</TD></TR>
<TR><TD>&lt;soh&gt;</TD><TD> 1</TD>     <TD>&lt;ht&gt;</TD><TD>9</TD>
    <TD>&lt;dc1&gt;</TD><TD> 17</TD>    <TD>&lt;em&gt;</TD><TD>25</TD></TR>
<TR><TD>&lt;stx&gt;</TD><TD> 2</TD>     <TD>&lt;nl&gt; &lt;lf&gt;</TD><TD>10</TD>
    <TD>&lt;dc2&gt;</TD><TD> 18</TD>    <TD>&lt;sub&gt;</TD><TD>26</TD></TR>
<TR><TD>&lt;etx&gt;</TD><TD> 3</TD>     <TD>&lt;vt&gt;</TD><TD>11</TD>
    <TD>&lt;dc3&gt;</TD><TD> 19</TD>    <TD>&lt;exc&gt;</TD><TD>27</TD></TR>
<TR><TD>&lt;eot&gt;</TD><TD> 4</TD>     <TD>&lt;np&gt;</TD><TD>12</TD>
    <TD>&lt;dc4&gt;</TD><TD> 20</TD>    <TD>&lt;fs&gt;</TD><TD>28</TD></TR>
<TR><TD>&lt;enq&gt;</TD><TD> 5</TD>     <TD>&lt;cr&gt;</TD><TD>13</TD>
    <TD>&lt;nak&gt;</TD><TD> 21</TD>    <TD>&lt;gs&gt;</TD><TD>29</TD></TR>
<TR><TD>&lt;ack&gt;</TD><TD> 6</TD>     <TD>&lt;so&gt;</TD><TD>14</TD>
    <TD>&lt;syn&gt;</TD><TD> 22</TD>    <TD>&lt;rs&gt;</TD><TD>30</TD></TR>
<TR><TD>&lt;bel&gt;</TD><TD> 7</TD>     <TD>&lt;si&gt;</TD><TD>15</TD>
    <TD>&lt;etb&gt;</TD><TD> 23</TD>    <TD>&lt;us&gt;</TD><TD>31</TD></TR>
<TR><TD> &nbsp;</TD><TD>&nbsp;</TD>   <TD> &nbsp;</TD><TD>&nbsp;</TD>
    <TD> &nbsp;</TD><TD>&nbsp;</TD>   <TD>&lt;sp&gt;</TD><TD> 32</TD> </TR>
</TABLE>
Table 81.1 Named Characters
</center>




<h2> Fixed-array fields </h2>


<PRE>define phrase basic-msg;
  &lt;stx>;
  field data = fixed-array ( 120, any );
  &lt;etx>;
end phrase;
</PRE>

The generic form of a fixed-array field definition is:
fixed-array ( <em> count </em> , <em>component</em> ).
<p>
A fixed-array denotes a portion of the phrase which is made up of a fixed number
of repetitions of a particular form. <em>Count</em> must be an integer constant.
<em>Component</em> can be any phrase part, even a complex phrase part. 
The component is usually a character class.
<p>
Character classes include:
<UL>
<LI><em>any</em> (all ascii characters), 
<LI><em>digit</em> (0-9), 
<LI><em>letter</em> (A-Z, a-z),
<LI><em>not</em>(<em>character-class,...</em>), 
<LI><em>or</em>(<em>character-class,...</em>).
</UL>

Examples:

<PRE>field myname= fixed-array(1024, any);
field whatever=fixed-array(5, digit);
field ab-data=fixed-array(10, begin variable-array(not&lt;nl&gt;)); &lt;nl&gt;; end)
</PRE>
Note that the name of the field can be freely chosen by the programmer. 

<h2> Variable-array fields </h2>


<PRE>define phrase mlp-msg;
 &lt;vt&gt;;
 field text= variable-array( not (&lt;fs&gt;));
 &lt;fs&gt;; &lt;cr&gt;;
end phrase;
</PRE>


A variable-array phrase describes a message part that is made up of a 
variable number of characters. 
<p>
The generic form of a variable-array field definition:
variable-array (<em>count</em>, <em>component</em>)
<p>
Component (a character class) can either be a character constant, a named character set
(digit, any) or a composition of a character set using <em>not</em> or <em>or</em>. 
The character-class
is almost always used to specify the allowed characters within the variable array with
the exception of some terminating character.
When parsing an inbound message, i.e. by looking at each succeeding character in
isolation, it can be deduced whether or not the character belongs to the array.
<p>
Note: the character-class <b>any</b> can only be used within a length-encoded region.




<h2>Length-encoded fields</h2>


<PRE>define phrase blob-data;
  length-encoded {encoding: network (bytes: 2), store-in: len } =
    begin
    field len = fixed-array (2, any);
    field blob = variable-array (any);
    end;
end phrase;
</PRE>

The programmable driver supports length-encoding of line phrases.
A length encoding describes the parts of the message a length encoding will
be calculated over and the field where the calculated length will be stored or
compared against.
<p>
The generic form of a length encoding is:

<PRE>length-encoded {encoding: encoding;
	store-in: field-name }=
begin
	msg-body
end;
</PRE>

<em>Encoding</em> is a required keyword and
can be one of ascii, native or network.


<PRE>define phrase basic-msg;
 field len = fixed-array (2, any);
 length-encoded { encoding: network ( bytes: 2 ), store-in: len } =
 begin
  &quot;KCONN &quot;;
  field msgType = fixed-array (6, any);
  &quot;M &quot;;
  field msgData = variable-array ( any );
 end;
end phrase;
</PRE>


<PRE>define phrase basic-msg;
    "DAT";  
    field len = fixed-array ( 3, digit );
    length-encoded { encoding: ascii ( width: 3, justification: right, pad: '0' ) 
                     , store-in: len } =
    begin
       field data = variable-array( any );
    end;
end phrase;
</PRE>



<h2>Phrase checking/checksums</h2>

PDL has built-in support for protocols that employ checksums or block-check characters.
The generic form for describing a phrase-check is:

<PRE>phrase-check {method: method,
	modulo: mod,
	encoding: encoding,
	store-in: field-name }=
begin
	msg-body-that-is-checked
end;
</PRE>

The phrase-check method is either <em>xor</em> (bytewise,0-255) or <em>add</em>.
Modulo (optional) must be an integer value. Encoding is a required keyword and
can be one of <em>ascii</em>, <em>native</em> or <em>network</em>.


<PRE>define phrase mjs-message;
 phrase-check { method: add, modulo:128, store-in: bcc } =
  begin
   &lt;sch&gt;;
   field seq-num = fixed-array ( 3,digit);
   &lt;stx&gt;;
   field text = variable-array (not(&lt;etx&gt;));
   &lt;etx&gt;;
  end;
 field bcc = fixed-array (3, digit);
 &lt;cr&gt;; &lt;lf&gt;;
end phrase;

define phrase basic-msg;
  &lt;stx>;
  phrase-check { method: xor, store-in: bcc } =
    begin field data = variable-array ( not(&lt;etb>));
    end;
  &lt;etb>;
  field bcc = fixed-array (3, digit );
  &lt;etx>;
end phrase;
</PRE>

<p>
Note: using the <em>phrase check continue</em> option it is possible to perform
the check over multiple sections within the message definition.


<PRE>define phrase basic-msg;
  &lt;stx>;
  phrase-check { method: xor, store-in: bcc, 
                 encoding: ascii ( width: 3, justification: right, pad: '0' )  } =
    begin field data1 = variable-array ( not(&lt;etb>));
    end;
  &lt;etb>;
  field bcc = fixed-array (3, digit );
  phrase-check continue =
    begin field data2 = variable-array ( not(&lt;etb>));
    end;
  &lt;etb>;    
  &lt;etx>;
end phrase;
</PRE>

<p>
Copyright 1998,2002
</BODY>
</HTML>
