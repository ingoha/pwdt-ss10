<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>


<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 100: MSI Tcl Extensions </h1>




The Integrator Monitor Statistics Interface (MSI)
 extensions to Tcl provide access to run-time state information and run-time statistics
describing the engine processes and/or threads. 

The run-time information is compiled by the <em>hcimonitordaemon</em> and stored
in the <em>shared memory region</em> ($HCISITEDIR/exec/monitorShmemFile).
<p>
This memory region is accessed by the <em>Status Report</em> in the <em>hcinetmonitor</em>,
by the <em>hcimsiutil</em> commandline utility 
(see the 3.8 Reference Guide regarding the topic "Engine Commands" for details) 
and by the MSI extensions to Tcl.

One use of hcimsiutil is to reset the statistics to 0. All statistics reported by MSI 
are cumulative until the counters are reset to 0 by using <b>hcimsiutil -Z</b>.

<p>
<b>The keyed lists returned by these procedures and the procedures themselves are
primarily intended for internal use, 
i.e. by the engine and by the commandline tools developed by
Quovadx (formerly Healthcare.com). Note that individual procedures may no longer exist in a future release
of the Integrator software, or that the keyed lists may contain different keys.</b>
<p>
The MSI-procedures are mostly used 'outside' of the engine, e.g. in Alert Scripts
, shell scripts or command line tools. Integrator version 3.8.1P supports the following
MSI procedures: msiAttach, msiTocEntry and msiGetStatSamples.
<p>

<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><B>msiAttach</B><BR>
Purpose: This function initializes the MSI-subsystem and attaches to its shared-memory-region. 
The MSI subsystem has to be initialized in order for the other MSI procedures to work.<BR>
Notes: Call this function once within the initialisation phase of an alert Tcl-procedure
or the init section of a TPS procedure. You are advised to always use this function
in combination with <em>catch</em> since calling this function multiple times results
in a Tcl error.<BR>
Examples:

<PRE>hcitcl>catch { msiAttach }
0
hcitcl>msiAttach 
Error: shared memory region is already attached
hcitcl>catch { msiAttach }
1
</PRE>

Known problem (3.3.0 - 3.6.x): PR2788: The msiAttach call clobbers the global variable HciConnName.
After executing msiAttach, the variable will always contain "hcitcl".
If you need the value of
this variable, save its value before calling msiAttach and store it afterwards.

</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><B>msiTocEntry ?threadName? ?varName | {}? </B><BR>
Purpose: This function returns the 'Table of contents' (Toc), listing some
basic information about the MSI data availble. 
If a threadName has been supplied, the run-time characteristics of the thread
will be returned.
If a threadName hasn't been supplied, this function will return the names of all threads.
The use of the varName parameter can be compared to that of keylget.
This function can be used to test for the presence of a thread's Toc by specifying {}
as the variable name.<BR>
Notes: A core dump will be created when msiAttach was not called previously.
The information provided by this function can also be displayed by using the
msi commandline tool: <b>hcimsiutil -dt</b>. <BR>
Examples:

<PRE>hcitcl>msiTocEntry
conn_0 his lab conn_2
hcitcl>msiTocEntry conn_0
{INDEX 1} {ALIVE 0} {CREATED 1} {NAME conn_0}
hcitcl>msiTocEntry conn_0 stats ; echo $stats
 # The variabele stats now contains a keyed list with MSI info.
hcitcl>msiTocEntry $threadName {} 
 # returns either 0 or 1, checks whether given threadName exists
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><B>msiGetStatSample threadName ?varName? </B><BR>
Purpose: This function returns a keyed list containing 
detailed MSI information of a particular thread.
An empty keyed list will be returned if the specified thread exists
but has never been initialized.<BR>
Notes: The information provided by this function can also be displayed by using the
msi commandline tool: <b>hcimsiutil -dd threadName</b>. <BR>
Examples:

<PRE>hcitcl>msiGetStatSample conn_0
{ALIVE 0} {PSTATUS down} {MSGSIN 0} {MSGSOUT 0} .... etc.
hcitcl>msiGetStatSample conn_0 stats 
 # The variabele stats now contains a keyed list with MSI info.
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><B>engprotostate</B><BR>
Purpose: This function returns the protocol status of the protocol thread
it is invoked from. (up, down, dead, ineof, opening, error) <BR>
Notes: This procedure is available within the engine only - it is *not* available at the command line.
To be used in (OB-) protocol threads only. 
This procedure doesn't require the initialization of the MSI region; it's a
shortcut for querying the value of the MSI PSTATUS key.<BR>
Examples:

<PRE>>engprotostate
up
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><B>pdsetstatus status ?error_message?</B><BR>
Purpose: This function sets the protocol status of the protocol thread
it is invoked from. (to up, opening, or error). The error_message will be shown in the protocol status window. <BR>
Notes: Only available in versions higher than 3.8.1P. This procedure is available within UPoC drivers within the engine only - it is *not* available at the command line.
To be used in UPoC protocol driver threads only. 
This procedure doesn't require the initialization of the MSI region.<BR>
Examples:

<PRE>if $database_update_error {
   pdsetstatus error
}
</PRE>
See <a href="m90.htm">Module 90:Protocol Driver UPoC</a> for additional usage notes.
</TD></TR>

</TABLE>



<h2> TOC entries </h2>

The returned statistics currently contain the following keys:

<UL>
<LI><b> ALIVE</b> <br>
    Thread status, 0 or 1
<LI><b>BYTESIN</b> <br>
    The number of bytes read in by this thread from its
    protocol connection.
<LI><b>BYTESOUT</b><br>
    The number of bytes written out by this thread to ist
    protocol connection.  
<LI><b>ERRORCNT</b> <br>
    The number of messages that were not delivered successfully.
<LI><b>FORWARDCNT</b> <br>
    The number of messages forwarded to an alternate thread.
<LI><b>IBLATENCY</b> <br>
    Inbound Latency, the time (cumulative, in seconds) necessary
    to process an inbound message. (i.e. the time a message was being processed 
    by the Inbound Protocol thread and the Translation thread).
<LI><b>IBPRESMSQD</b><br>
    Depth of the Inbound Pre-TPS Queue.
<LI><b>IBPOSTSMSQD</b><br>
    Depth of the Inbound Post-TPS Queue.
<LI><b>INTERTHREAD</b> <br>
    The interthread section is a list of keyed lists. Each keyed list provides
    information related to a particular thread about the routing and translation of messages.
    <UL>
    <LI><b> NAME</b> <br>
       Name of the thread messages are routed to/from.   
    <LI><b> NRCVD</b><br>
       Number of messages received from the NAME thread.
    <LI><b> NSENT</b><br>
       Number of messages sent to the NAME thread.
    <LI><b> POSTXLTQD</b><br>
       Depth of the Post-Translation Queue associated with the NAME thread.
    <LI><b> TIMEONQ</b> <br>
       Time on queue, the total time that the message spent waiting on queues
       within the system.
    <LI><b> TOTLATENCY</b> <br>
       Total latency for the NAME thread. 
    <LI><b> XLATETIME</b> <br>
       Translation time. 
    </UL> 
<LI><b>LASTEXTRACT</b>
     The last time (expressed in ticks) the MSI data was accessed.
<LI><b>LASTUPDATE</b>
     The last time (expressed in ticks) the MSI data was updated by the minitor daemon.
<LI><b>MSGIN</b> <br>
     The number of messages read in by this thread from its protocol
     connection.
<LI><b>MSGOUT</b> <br>
     The number of messages written out by this thread to its 
     protocol connection.
<LI><b>OBDATAQD</b> <br>
     The depth of the Outbound (Post-TPS) Data Queue. 
     The number of <em>Pending</em> messages is equal to the sum of OBDATAQD and OBREPLYQD.
<LI><b>OBLATENCY</b> <br>
     Outbound Latency, the time (cumulative, in seconds) to deliver an
     outbound message. (i.e. the time a message was being processed by the Outbound
     Protocol thread).
<LI><b>OBPRESMSQD</b> <br>
     The depth of the Outbound Pre-TPS (Data) Queue. 
<LI><b>OBREPLYQD</b><br>
     The depth of the Outbound (Post-TPS) Reply Queue. 
     The number of <em>Pending</em> messages is equal to the sum of OBDATAQD and OBREPLYQD.
<LI><b>PLASTERROR</b> <br>
    Date and time (expressed in ticks) of the last protocol error. 
<LI><b>PLASTERRTEXT</b>
     Textual description of the last protocol error.
<LI><b>PLASTREAD</b>
     The last time (expressed in ticks) the protocol thread performed a Read operation.
<LI><b>PSTATUS</b> <br>
     The protocol status. <b>up, down, dead, ineof, opening, error.</b>
<LI><b>START</b> <br>
     The last time (expressed in ticks) the thread was started.
<LI><b>STOP</b> <br>
     The last time (expressed in ticks) the thread was stopped.
<LI><b>TOTLATENCY</b> <br>
     Total Latency, total of inbound and outbound latency (cumulative, in seconds).
<LI><b>XLATECNT</b> <br>
     Number of messages that have been translated by this thread.
</UL>

<p>
See also the <a href="m100v.htm">MSI Procedure Examples</a>.

<p>
Copyright 1998,2002 Health-Comm GmbH
</BODY>
</HTML>
