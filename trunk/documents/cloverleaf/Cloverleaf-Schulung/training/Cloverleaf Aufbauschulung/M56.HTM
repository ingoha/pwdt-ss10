<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>



<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 56: Normalization of Non-Standard Message Formats </h1>





<h2> Introduction </h2>

Messages that are to be processed by the communication engine or messages that are 
to be sent by it may not comply with any of the data formats supported by the Integrator.
Even when the messages itself complies with a standard data format, 
it may still require processing, e.g. if the message is received in fragments or in a batch.
This module will use the term <em>non-compliant message</em>
to refer to non-compliance at both the OSI Presentation Layer as well as the
OSI Session layer.
<p>
<center><img src="images/arch1.gif"><BR>
Figure 1 Messageflow 
</center>
<p>
When an external system uses non-compliant messages 
the communication engine won't be able to route (other than <em>raw</em>) or translate
the messages. 
The message can't be parsed (by grm/xpm) by the engine and hence it can't be translated.
<p>
In order to allow the processing of 
non-compliant messages by the communication engine, the following TPS procedures
can be used:
<UL>
<LI><b>Transformation of a non-compliant message to a compliant message.</b> <BR>
This TPS procedure, which is usually the first procedure in the IB TPS, 
transforms the message
from its non-compliant message format to a compliant message format. 
The structure/layout of the message is transformed, not the content itself.

<LI><b>Transformation of a compliant message to a non-compliant message</b><BR>
This procedure, which is to be used as the last procedure in the OB-TPS, transforms
the message from a compliant message format to a non-compliant message format.
</UL>

By using these transformation procedures the messages processed by the engine are compliant
with one of the supported mesage formats 
(which is what Integrator needs for routing and translation purposes)
while at the same time they may have been received or
will be delivered in a non-compliant message format.

<h2> 1. Normalization at the Session Layer </h2>

Normalization at the OSI Session Layer often amounts to performing
many-to-one message transformations (a.k.a. Coalescing) or one-to-many message transformations
(a.k.a. Splitting).
<p>
Note that this type of normalization process can also be accomplished by using a PDL or 
using the UPoC protocol driver.

<h2> 1.1 Splitting </h2>

Splitting is the process of transforming one message into multiple
messages or message fragments. This process is also known as one-to-many
message transformation. 
Splitting may be required for 2 reasons:

<UL>
<LI><b>Inbound Batches/Interchanges (Session/Presentation Layer)</b><br>
Inbound messages that contain a batch of (other) messages need to be split
into individual messages. This is usually executed in the Inbound TPS.
The last_in_group flag can be used to mark the last message in the batch.
This flag is required when the messages (once translated) are to be send
as a batch. 
A couple of useful procedures of this type of procedure are provided with Integrator:
hciEDIFACTsplitinterchange and hciX12splitinterchange (3.5+).
<LI><b>Outbound Message Fragment (Session Layer)</b><br>
If the destination system has a limited buffer size, the outbound message has
to be split into message fragments that can be received by the destionation system.
This type of splitting is executed in the Outbound TPS.
<LI><b>Outbound messages (Presentation Layer)</b><br>
One-to-many transformation at the presentation layer 
is supported by the translation GUI using the ITER, 
CONTINUE, SEND and SUPRESSS translation actions.
</UL>

<h2> 1.2 Coalescing </h2>

Coalescing is the process of transforming multiple messages into one message.
This process is also known as many-to-one message transformation.

<UL>
<LI><b>Outbound Batches/Interchanges (Session/Presentation Layer)</b><br>
Outbound messages that are comprised of a batch of (other) messages need to
be generated in the Outbound TPS. Individual messages have to be coalesced
and a batch message, comprised of multiple messages has to be generated. 
The last_in_group flag (if set) can be used to detect the last message to
be stored in the outbound batch message.
A couple of useful procedures of this type of procedure are provided with Integrator:
hciEDIFACTbuildinterchange and hciX12buildinterchange (3.5+).
<LI><b>Inbound Message Fragments (Session Layer)</b><br>
When the source system sends multiple message fragments that are to be translated to a single
outbound message the inbound messages have to be <b>coalesce</b>d to form a single message.

The source system may send multiple message fragments either because
of its limited buffer size, or because its concept of a message differs from that
used in the Integrator. The coalescing process takes place in the Invound TPS.

<p>
<center><img src="images/coalesc.gif"><BR>
Figure 2 Coalescing
</center>
<p>
The coalescing of inbound messages is done by an IB-TPS procedure. 
This procedure processes the inbound messages and keeps those messages that are part
of a combined message in memory until all messages that need to be coalesced (messages
1,2,3 and 4 in the above figure) have been
processed. Only then will the coalesced message (message 1-2-3-4 in the above figure)
be processed by the engine itself. 
Messages that are of a type that doesn't require coalescing are unaffected by the
coalescing procedure (e.g. message 5 in figure 2).
<p>
The procedure can be seen as a state machine: the script has to be able
to determine what messages (and in what order) are to be coalesced.
It has to be able to check if all required fragments have been received before
coalescing. If messages are received in an out of order sequence
or if a message fragment is missing the remaining fragments will have to be placed
in the error database.
</UL>




<p>See <a href="m56v.htm">Examples: Coalescing</a>.

<h2> 2. Normalization at the Presentation Layer</h2>

When a source system sends messages that are not compliant with
any of the supported formats (HL7, HRL, VRL, Edifact, X12, FRL and SWIFT), 
the messages have to be normalized to a supported message format.

<p>
For example: a transformation to HL7 results in a message that conforms to the grammar rules
as defined for HL7 messages but of which the content does't need to conform to HL7 at all.

<p>
From version 3.6 onwards Integrator supports VRL (Variable Record Length),
which supports delimited as well as tagged field formats, and HRL 
(Hierarchical Record Layout). The introduction of these recordt types greatly
decreases the need for reformatting procedures.

<p>
Generally message types not covered by any of the standard formats have a structure 
that is either
a combination of a FRL and variable length messages or some other structure.
<p>
Inbound messages of these types have to be parsed in a Tcl procedure, after which the
contents of the various fields can be stored (using grmstore) in a message object
using a supported message structure.
The contents of fields in outbound messages
have to be fetched and a non-compliant message has to be constructed and send in an 
Outbound TPS procedure.

There are some <a href="m56x.htm">procedures internal to Integrator</a> which can be used to 
aid this type of message transformation.

<p>
<b>Example:</b> (Field IDs, Field Length pairs)

<PRE>0001,00062372350005,0001Q0007,0006Public0012,0004John0015,0000</PRE>


The attributes are identified by a number. Attribute (field) 1, of length 6, has the
value '237235'. Attribute 5, of length 1, has the value 'Q'. etc. etc. Note that attribute
15 has the 'active null' value.

<p>
<b>Example:</b> (Tcl List)

<PRE>237235 {John Q Public} {234 Valley Road} {10000 Dallas TX}</PRE>


Data structured as a Tcl list is typically the result of an ODBC query or of a
preceeding normalization stage.



</UL>
<!------ end of complex normalizations ----------->


<p>
Copyright 1998,2001 Health-Comm GmbH
</BODY>
</HTML>
