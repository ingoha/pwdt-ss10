<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>



<h1>
<img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 51: TPS Procedure, examples </h1>






<h2>Generating a message in the IB TPS</h2>

When a system wishes to receive (protocol level/application level) acknowledgements these
messages can be generated in an IB TPS.
Protocol level acknowledgements are mostly created by the protocol driver, e.g. a PDL.
However, whenever the content or layout of the acknowledgement message is complicated,
the IB TPS is often used to construct the acknowledgement message. 
Within an IB TPS it's easier to parse the data message and contsruct a reply
by using the <em>msg</em> and <em>grm</em> extensions. These features are not available
within a protocol driver.
<p>
Within this type of TPS, the data message received gets a CONTINUE
disposition whereas the ack generated (either a Data or a Reply message)
is sent in the opposite direction using the OVER disposition. 
<P>

The following example generates an ACK message. This procedure is used in the IB-TPS. 
Note that in this case the acknowledgement message is of type Data.


<PRE>######################################################################
# Name:		createWOPSYSack
# Purpose:	Create an ACK for the WOPSYS just received
# UPoC type:	IB TPS
# Args: 	tps keyedlist containing the following keys:
#       	MODE    run mode ("start", "run" or "test")
#       	MSGID   message handle
#
# Returns: tps disposition list:
#          CONTINUE   of inbound messages
#          OVER       of created ACK msgs
#

proc createWOPSYSack { args } {
    keylget args MODE mode              	;# Fetch mode
    set dispList {}

    switch -exact -- $mode {
        start {
            # Perform special init functions
        }

        run {
	    # 'run' mode always has a MSGID; fetch and process it
            keylget args MSGID mh

            # A WOPSYS ack consists of a concatenation of the string "99ACK"
            # and the message type of the inbound message

            # preserve metadata by using msgcopy
            set ackmh [msgcopy $mh]

            set msgType [msgget $mh 0 2]
            msgset $ackmh "99ACK$msgType"
 
            lappend dispList "CONTINUE $mh"
            lappend dispList "OVER $ackmh"
        }

        shutdown {
        }

        default {
	    error "Unknown mode '$mode' in createWOPSYSack"
        }
    }
    return $dispList
}
</PRE>



<h2>Inbound filtering of messages</h2>


The following example ilustrates the use of an IB TPS procedure. 
Suppose a systems sends messages to Integrator and we need a filtering/checking
procedure before processing/parsing/translating the message.
<p>
The functionality of the procedure below is as follows: if the message is shorter than 100 bytes
then the message is assumed to be invalid and will be killed. If the message
is larger than 4096 bytes then the message should be split into 2 messages,
the first containing the first 4096 bytes and the second any remaining bytes.


<PRE>######################################################################
# Name:         checkIncomingMessages
# Purpose:      checks the validity of incoming messages, splits message
#               if longer than 4096 bytes.
# UPoC type:    tps
# Args:         tps keyedlist containing the following keys:
#               MODE    run mode ("start", "run" or "time")
#               MSGID   message handle
#               ARGS    user-supplied arguments:
#              	        None.
#
# Returns: tps disposition list:
#          KILL         of all messages shorter than 100 bytes; 
#          CONTINUE     of all other messages.
#

proc checkIncomingMessages { args } {
    keylget args MODE mode              	;# Fetch mode

    set dispList {}				;# Nothing to return

    switch -exact -- $mode {
        start {
            # 'start' mode is called once at thread startup
            return ""
        }

        run {
	    # 'run' mode always has a MSGID; fetch and process it
            keylget args MSGID mh
            
            if { [msglength $mh] < 100 } {
                # message is too short and has to be killed
                # -append message handle to disposition list with a KILL disposition
                lappend dispList "KILL $mh"
            } else {
                # message size >= 100, check to see if we need to split the message

                if {[msglength $mh] > 4096} {
                    # message length > 4096, message contents have to be split 
                    # we need the msg contents now, to do the actual splitting.. 
                    set msgContent1 [msgget $mh 0 4096]
                    set msgContent2 [msgget $mh 4096 end]
                    # we now have the right contents for 2 (!!) messages, but
                    # we have just 1 message handle: $mh.
                    # Create another message object, assign its handle to mh2 :
                    set mh2 [msgcopy $mh]
                    # associate the message handles with their new contents
                    msgset $mh $msgContent1
                    msgset $mh2 $msgContent2
                    # -append 2 (!!) message handles to the disposition list with
                    # CONTINUE dispositions.
                    lappend dispList "CONTINUE $mh" 
                    lappend dispList "CONTINUE $mh2"
                } else {
                    # message size <= 4096, splitting won't be necessary
                    # -append message handle to disposition list with a CONTINUE disposition
                    lappend dispList "CONTINUE $mh"
                }

            }
        }

        shutdown {
        }

        default {
	    error "Unknown mode '$mode' in checkIncomingMessage"
        }
    }

    return $dispList
}
</PRE>


<p>
Copyright 1998,2001 Health-Comm GmbH
</BODY>
</HTML>
