<HEAD>
        <TITLE>Advanced Technical Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>


<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Advanced Technical Training </H1>

<h1> Module 100: MSI Tcl Extensions, Examples </h1>







<PRE># GENERIC PROCS: gen_msi_procs.tcl - supporting procs dealing with
#                                    msi extensions.
# Note: before calling any of the msi procs in this file, be sure that
#       the msi engine extensions have been initialized by calleng
#       msiAttach. (once per process).

######################################################################
# proc gc_threadUpAndRunning - determines whether a given thread is 
#                        alive and its protocol driver status is OK.
# NOTE: Running means that proto status is UNequal to any of the
#       following: dead, down, opening, error.
#
proc gc_threadUpAndRunning { threadName } {
   if { [msiGetStatSample $threadName msiVals ] > 0 } {
	# threadName valid
        set alive 0
        keylget msiVals ALIVE alive
        # thread alive status, '0' = dead, '1' = alive
        set pstatus not_set
        keylget msiVals PSTATUS pstatus
        # protocol status, e.g. 'ineof' 'up' 'down' 'dead' 'opening' 'error'
        return [ expr { $alive == 1 && [ lsearch -exact { \
                        down dead opening error } $pstatus ] &lt; 0 } ]
   } else {
	# threadName invalid
        echo gc_threadUpAndRunning(gen_msi_procs.tcl): thread \
             $threadName doesn't exist.
        return 0
   }
}

######################################################################
# Name:		gc_killMsgIfDestDown
# Purpose:	Kills msg if the msg-destination is not 'up and running'  
# UPoC type:    tps (OB TPS Stack)
# Args: 	tps keyedlist containing the following keys:
#       	MODE    run mode ("start", "run" or "test")
#       	MSGID   message handle
#
# Returns: tps disposition list:
#          KILL - if the msg-destination is not 'up and running' OR 
#                 msg-destination cannot be resolved as being a valid
#                 threadname.
#          CONTINUE - otherwise.

proc gc_killMsgIfDestDown { args } {
    keylget args MODE mode              	;# Fetch mode
    set dispList {}

    switch -exact -- $mode {
        start {
            # Perform special init functions
            catch { msiAttach }
        }

        run {
	    # 'run' mode always has a MSGID; fetch and process it
            keylget args MSGID mh

            set dest [ msgmetaget $mh DESTCONN ]
            # msgDestThread metadata field
            if { [ gc_threadUpAndRunning $dest ] > 0 } {
                lappend dispList "CONTINUE $mh"
            } else {
                lappend dispList "KILL $mh"
            }
        }

        time {
            # Timer-based processing
	    # N.B.: there may or may not be a MSGID key in args
        }

        default {
	    error "Unknown mode '$mode' in gc_killMsgIfDestDown"
        }
    }

    return $dispList
}

</PRE>

<h2>Using run time information to forward a message</h2>

Suppose the application of a vendor is installed on two separate sets of hardware for
backup reasons. It is not in a cluster environment, so a separate version of 
their socket software lives on two separate clients. Run-time information can be used
to switch to a secondary IP address if the first IP address is not available.
<p>
 
The following procedure, thread_forward.tcl, that would go 
in the Outbound Configure: TPS Outbound data stack of the primary 
outbound thread accomplishes the forwarding. 
You would configure two outbound threads, one the 
primary and one the backup, with the proper IP address and socket.  This 
procedure checks the protocol state of the primary thread.  If the state does 
not equal "up" it sets the Destination Connection metadata, "DESTCONN", 
to the second thread and does a SEND (or PROTO) to the second thread. If the state 
is up it CONTINUEs the message to the primary connection.   

<p> 
Note that the name of the secondary thread has to be provided as a user provided
argument.
 

<PRE>################################################################
# Name:         thread_forward 
# Purpose:      Forwards a message to another thread if the protocol 
#               status of the current thread is unequal to 'up'.
# UPoC type:    tps 
# Args:         tps keyedlist containing the following keys: 
#               MODE    run mode ("start", "run" or "time") 
#               MSGID   message handle 
#               ARGS    user-supplied arguments: 
#                       args is a keted list containing the following keys:
#                       BTHREAD name of the backup_thread
# 
# Returns: tps disposition list: 
#          CONTINUE     if the protocol status is equal to 'up'
#          SEND         otherwise
# 
 
proc thread_forward { args } { 
    keylget args MODE mode                      ;# Fetch mode 
    keylget args ARGS uarg                      ;# user arguments
 
    set dispList {}                             ;# Nothing to return 
 
    switch -exact -- $mode { 
        start { 
            # Perform special init functions 
            # N.B.: there may or may not be a MSGID key in args 
        } 
 
        run { 
            # 'run' mode always has a MSGID; fetch and process it 
            keylget args MSGID mh 
            keylget uarg BTHREAD backupThread

            set state [engprotostate] 
            if {![cequal $state "up"]} { 
                 msgmetaset $mh DESTCONN $backupThread
                 lappend dispList "PROTO $mh" 
            } else { 
                 lappend dispList "CONTINUE $mh" 
            } 
        } 
 
        time { 
            # Timer-based processing 
            # N.B.: there may or may not be a MSGID key in args 
        } 
 
        default { 
            error "Unknown mode '$mode' in thread_forward" 
        } 
    } 
 
    return $dispList 
} 
</PRE> 
Example courtesy of Greg Wood