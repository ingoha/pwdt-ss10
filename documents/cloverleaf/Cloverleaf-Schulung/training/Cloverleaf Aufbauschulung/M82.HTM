<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>


<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 82: PDL: Styles</h1>




Many protocols interact using a similar
set of semantics, but they use a different set of encoding characters.
It should be easy to define these common interaction models.
&quot;styles&quot; provide a mechanism for automatic PDL code
generation to manage two forms of message interaction:
<UL>
<LI><b>Basic</b> No protocol level ack or
nak processing. The messages are encoded and delivered.
<LI><b>Ack/Nak</b> Simple ack/nak management.
When a message is written, the driver waits for an ack to return.
It resends the message upon receipt of a nak. When reading a message,
the driver acks if the message is well formed. It sends a nak
otherwise.
</UL>
<P>

<h2> Basic style PDLs </h2>

The following two figures show the message flow as it is affected by the basic-style.

<p>
<center>
<img src="images/pdl_A.gif"> &nbsp;&nbsp;&nbsp; <img src="images/pdl_b.gif">
<BR>Figure 82.1 Message flow using a basic style PDL
</center>
<p>
The message flow shown above is the same as one of the standard length-encoded
tcp/ip protocols accessable thru the Network Configurator. 
Messages that are to be transmitted are encoded according to the phrase definition
and send to the external system. Message received are matched against the
same phrase definition, the encoding characters are stripped off and the
message is forwarded to the Integrator engine itself.
<p>
Instead of defining a full set of
Tcl routines to control the message flow within the PDL (as in the case of a customized PDL),
 one can use the hci_pd_msg_style
command to generate the code automatically. The command syntax
is:
<PRE>hci_pd_msg_style basic {keyword:value ....}
</PRE>

<P>
Keywords available for use with the
&quot;basic&quot; style:
<UL>
<LI><b>phrase:</b>&lt;name&gt; The name of
the phrase to use to encode/decode the message. (required)
<LI><b>field:</b>&lt;name&gt; The name of the
field (from the phrase) into/from which the message data should
be placed/obtained. This field denotes the actual <em>engine message</em>. (required)
<LI><b>dir:</b>&lt;direction&gt; Indicates
the direction the driver will operate in. Choices are &quot;bidir&quot;
and &quot;obonly&quot;. &quot;bidir&quot; is default. You must
define the &quot;any-byte&quot; phrase (used to ignore all inbound
data) if you specify &quot;obonly&quot;.
<LI><b>resync:</b>&lt;char&gt; If specified,
then use resync logic on any error/timeout. Try to resync the
input buffer to the char specified. Char must be either a single
character or specified in hex (e.g., \x06). If not specified,
then all data is tossed on error/timeout.
<LI><b>timeout:</b>&lt;msecs&gt; general timeout
(read/write) in micro-seconds.
<LI><b>rtimeout:</b>&lt;msecs&gt; read specific
timeout.
<LI><b>wtimeout:</b>&lt;msecs&gt; write specific
timeout.
</UL>
<P>
<em> See <a href="m82Ab.htm">mlp_tcp.pdl</a> and sms_tcp.pdl for examples of basic style PDLs. </em>

<h2> Acknak style PDLs </h2>

The acknak style takes care of the handling of acks and naks as well. Acks/naks will
be generated for messages that are receieved just as acks/naks received will be processed.
<p>
<center>
<img src="images/pdl_C.gif"> &nbsp;&nbsp;&nbsp; <img src="images/pdl_D.gif">
<BR>Figure 82.2 Message flow using an acknak style PDL
</center>
<p>
Messages that are to be transmitted are encoded according to the phrase definition
and send to the external system. 
The PDL core driver will listen for either a NAK or a NAK message before continuing.
If the driver received an ACK, it will then be able to send the next message (if any).
If the driver received a NAK, it will resend the message a number of times, either
until an ACK is received or until a certain threshold has been reached.
The ACK and/or NAK messages themselves are not forwarded to the engine itself.
<p>
Message received are matched against the
phrase definition. If the message received could be matched agains a phrase
then an ACK will be sent to the sending system, the encoding characters will
be stripped off and the message will be forwarded to the Integrator engine itself. 
<p>
Instead of defining a full set of
Tcl routines to control the message flow within the PDL (as in the case of a customized PDL),
 one can use the hci_pd_msg_style
command to generate the code automatically. The command syntax
is:
<PRE>hci_pd_msg_style acknak {keyword:value ....}
</PRE>


<P>
Keywords for use with the &quot;acknak&quot;
style include all &quot;basic&quot; keywords, plus:
<UL>
<LI><b>ackphrase:</b>&lt;name&gt; The name
of the phrase that recognizes an ACK msg. (required)
<LI><b>nakphrase:</b>&lt;name&gt; The name
of the phrase that recognizes a NAK msg (required)
<LI><b>naktries:</b>&lt;num&gt; The number
of NAKs to allow prior to giving up on a write.
<LI><b>tmotries:</b>&lt;num&gt; The number
of timeouts prior to giving up on a write.
</UL>
<P>

<em>See <a href="m82Aa.htm">msmeds_async.pdl</a> and orsos_tcp.pdl for examples of acknak style PDLs. </em>

<h2> Notes </h2>

Even if a driver has been defined using a
style, individual procedures can be overriden/overloaded (e.g.,
hci_pd.initialize, to sent some kind of handshaking msg).

<p>
Copyright 1998,2002
</BODY>
</HTML>
