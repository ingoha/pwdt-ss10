<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>



<h1>
 <img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 18: Extended Tcl (TclX)</h1>





<h2>The Tcl interpreter</h2>

Integrator uses the Tool Command Language (Tcl) for its scripting extensions.
The internals of the engine use multiple concurrent Tcl interpreters.
The Tcl interpreter can be used in its interactive mode by starting it
from the command line with the <EM>hcitcl</EM> command. 
The root and site environment variables have to be set before the interpreter
can be started. The interpreter is mostly used interactively in order
to test snippets of Tcl code before they are actually used as an extension to the engine.
<em>hcitcl is usually pronounced like 'hickytickle'</em>
<P> Open a command line session, check with the aid of showroot whether or not
the root and site environment variables have been set, and start the interpreter with
<EM>hcitcl</EM>.

<p>
The <b>hcitcl</b> interpreter consist of Tcl (version 8.3), 
Extended Tcl (TclX) and Quovadx (formerly HCI) extensions to Tcl. 
Extended Tcl is a public domain extension to 
Berkeley Tcl. Tcl and Extended Tcl are GNU-tools and are consequently freely
distributable.
<p>
TclX contains a number of very useful extensions to Tcl, including:
<ul>
<li>Access to a number of O.S. (Nt/Unix) system calls, including process management;
<li>File I/O commands;
<li>Extensive 'list' facilities especially in the form of keyed lists;
<li>String and character oriented procedures;
<li>Date and time procedures.
</ul>
The Quovadx extensions to Tcl cover the following areas of functionality:
<ul>
<li>The <em>message</em> object and message object manipulation procedures (msg and msgmeta);<BR>
    See <a href="m20.htm">Module 20: Msg Tcl Extensions</a>.
<li>Transliteration (character set translation);<br>
    See <a href="m54.htm">Module 54: Character Encoding</a>. 
<li>The <em>datum</em> object and datum object manipulation procedures (dat);<br>
    See <a href="m40.htm">Module 40: Datums</a>.
<li>Generic Record Manager (grm, message parser) and Xlation Pseudo Machine (xpm);<BR>
    See <a href="m41.htm">Module 41: Grm & xpm</a>.
<li>Monitor Statistics Interface (msi).<BR>
    See <a href="m100.htm">Module 100: MSI extensions</a>.
</ul>

The Tcl interpreter supports a feature called Auto-Loading.
If a specified procedure doesn't exist within the interpreter, the
engine searches the directories specified by the $TCL_AUTO_PATH environment
variable for <em>tclIndex</em> files.
The tclIndex file contains an index of files and tcl-procedures.
It is used in order to determine the location of a particular procedure.
<p>
Within the Integrator engine, Tcl procedures are normally stored in the
$HCIROOT/tclprocs and $HCISITEDIR/tclprocs directories. The engine 
creates (and updates) the tclIndex files in these directories. Both
directories are used for auto loading.
<p>
The tclIndex file can be explicitly (re-)created by using the <em>mktclindex</em> command.
This will cause all files with the extension tcl to be sourced. Any procedures defined
within these files will be referenced to in the tclIndex file.

<h2>Tcl - References </h2>
The following online references or other reference materials may provide you with 
additional information about Tcl and extended Tcl:
<ul>
<li><em><b>help</B> procedureName</em> within the Tcl interpreter.
<li>call the procedure without any parameters within the Tcl interpreter.
<li><em><b>info body </B>procedureName</em> within the Tcl interpreter.
<li>see "Integrator Reference Guide" for TclX and Quovadx Tcl extensions.
<li>see "Tcl and the Tk toolkit", J.K. Ousterhout, Addison-Wesley.
<li>see the Tcl FAQ (available via http://sunscript.sun.com).
</ul>

The list below contains a description and a usage of a number of Tcl en TclX commands
that are used on a regular basis when one is developing scripts within the Integrator
environment. 
The flag that preceeds a procedure name (**,* or --) indicates
the frequency of use of the procedure (frequently, regularly, almost never)
and hence its importance.

<h2> A refresher of TCL </h2>

The lines in a TCL script beginning with a # indicate comments.
Please note the statement terminator for Tcl is either a ; 
or a new-line so comments can also appear on the same line as a 
Tcl code provided the code is terminated with a ; such as:

<PRE>set myvar "myvalue";      # set the value of myvar
</PRE>


<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>split string splitChar </b><BR>
Purpose: This function splits a string into components based on
the splitting character <em>splitChar</em>.
The result of this function is a Tcl list of components.
<BR>
Notes: Mostly used to split a message based on a delimiter character. 
The delimiter character is quite often a Tcl special character, e.g.
\n (newline, ASCII 10), \r (carriage return, ASCII 13) or \xNN (hexademical 
representation of character NN).
The joining of message components based in a joining character can be accomplished
with the fuction <b>join</b>. <BR>
Examples:

<PRE>hcitcl>set msg "Johnson,Peter,12,Engelwood Street,London,W1 5PX"
hcitcl>set l [split $msg ,] ; echo [lindex $l 1] [lindex $l 0]
Peter Johnson
hcitcl>set msg "MSH|1|2|3|4\rPID|1|2|3\n"
hcitcl>set segList [ split $msg "\r" ] ; echo $segList
MSH|1|2|3|4 PID|1|2|3\n
hcitcl>set fieldList [ split [ lindex $segList 0 ] "|" ] ; echo $fieldList
MSH 1 2 3 4
hcitcl>join $fieldList *
MSH*1*2*3*4
</PRE>

</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>regsub ?switches? exp string subSpec varName</b><BR>
Purpose: This function replaces one (or more) occurences of the string <em>exp</em>
with the string <em>subSpec</em>.
The result of this function is the number of replacements.
See <b>tclhelp</b> for full documentation.<BR>
Examples:

<PRE>hcitcl>set msg "1234@dss99@blub@uwe"
hcitcl>regsub @ $msg "|" msg2 ; echo $msg2
1
1234|dss99@blub@uwe
hcitcl>regsub -all "\[0-9\]@" $msg "^" msg3 ; echo $msg3
2
123^dss9^blub@uwe  
hcitcl>regsub -all @ $msg "" msg ; echo $msg
3
1234dss99blubuwe
</PRE>

</TD></TR>

</TABLE>


<h2> TclX: Keyed lists </h2>

This section cointains a description of a number of TclX procedures
that allow the manipulation of 'keyed lists'. 
Type <b>keyl</b> within the Tcl interpreter to get a full listing
of all keyed list commands. 
<p>
A keyed list differs from a list in that its elements are key/value pairs,
accessable by key. As such it provides the functionality of a simple
database table.
<BR> When keyed lists are nested within keyed lists, a depth greater than 2
is discouraged.
<p>
<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>keylget listVar key ?returnVar? </b><BR>
Purpose: This function returns the value associated with a specific key.
The value will be placed in the variable with name <em>returnVar</em>.
If the name of a returnVar has not been specified, the result of this
function will be the value associated with the specified key.
An error occurs if the specified key doesn't exist.<BR>
Examples:

<PRE>hcitcl>set kl {{A 100} {B 200}}
hcitcl>keylget kl A {}  ;# determine if given key in list
1
hcitcl>keylget kl A
100
hcitcl>keylget kl B b_value ; echo $b_value
200
hcitcl>keylget kl C c_value ; echo $c_value
##### error: variable c_value doesn't exist
hcitcl>keylget kl C
{}
hcitcl>set d_value {} ; keylget kl D d_value ; echo $d_value
{}
hcitcl>set kl {{foo {{A 100} {B 200}}}} ; keylget kl foo.B
200
</PRE>

</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>keylset listVar key value ?key value?... </b><BR>
Purpose: This function stores a key and its associated value in a keyed list.<BR>
Examples:

<PRE>hcitcl>keylset kl A 100 ; echo $kl
{A 100}
hcitcl>keylset kl B 200 ; echo $kl
{A 100} {B 200}
hcitcl>keylset kl2 foo $kl ; echo $kl2  ;# nested keyed lists
{foo {{A 100} {B 200}}}
hcitcl>keylget kl2 foo.A  ;# query sublist key
100
hcitcl>keylset kl A 100 B 200 C 300 D 400 ; echo $kl
{A 100} {B 200} {C 300} {D 400}
hcitcl>for { set i 0 } { $i &lt; 10 } { incr i } {
         keylset b $i [expr { $i * $i } ]
       }
hcitcl>echo $b
{0 0} {1 1} {2 4} {3 9} {4 16} .. {9 81}
</PRE>

</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
* </TD><TD><b>keylkeys listVar</b><BR>
Purpose: This function returns a list of all keys contained in a keyed list.<BR>
Examples:

<PRE>hcitcl>keylset kl A 100 B 200 ; echo $kl
{A 100} {B 200}
hcitcl>keylkeys kl
A B
hcitcl>foreach key [keylkeys kl] { echo [ keylget kl $key ] }
100 
200
</PRE>

</TD></TR>

</TABLE>


<h2> Files </h2>
<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>read_file <em>fileName</em> ?nonewline?</b><BR>
Purpose: This function returns the contents of a file.<BR>
Notes: Often used to read the entire contents of a file and store the contents in a variable. 
The use of read_file and write_file is strongly discouraged if the characters in the file are encoded (use different character set) than the Integrator. See <a href="m54.htm">Module 54: Character Encoding</a> for details.<BR>
Examples:

<PRE>hcitcl>set h [ read_file /etc/hosts ]
hcitcl>set h [ split $h "\n" ]
hcitcl>foreach hh $h {
  if [ cequal [ lindex $hh 0 ] "192.168.5.194" ] {
    echo $hh
  }
}
192.168.5.194    ceres   # John's box
</PRE>
</TD></TR>
<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>write_file <em>fileName string</em> ?string...? </b><BR>
Purpose: This function writes the contents of a variable to a file.
If the file doesn't exist, it will be created. <BR>
Notes: The use of read_file and write_file is strongly discouraged if the characters in the file are encoded (use different character set) than the Integrator. See <a href="m54.htm">Module 54: Character Encoding</a> for details. <br>
Examples:

<PRE>hcitcl>set a "some value, could also be a (keyed) list."
hcitcl>write_file /tmp/store.tmp $a
</PRE>
</TD></TR>
</TABLE>

<h2> Tcl: Error handling </h2>

Procedures written in Tcl and Extended Tcl may generate run-time errors in certain circumstances.
Tcl allows a programmer to catch these errors using the <em>catch</em> procedure.
<p>

<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>catch command ?varName? </b><BR>
Purpose: This function catches any run-time errors that may occur during the 
execution of the <em>command</em> Tcl code. The result of this function
is either 0 or 1, depending on whether an error did occur.
If an error did occur and a <em>varName</em> was supplied, then a description
of the error will be placed in this variable. If a <em>varName</em> wasn't supplied
the error description and a 'stackdump' can be found in the global variable 
<em>errorInfo</em>.<BR>
Examples:

<PRE>hcitcl>expr { 1 / 0 }
divide by zero
hcitcl>catch { expr { 1 / 0 } }
1
hcitcl>echo $errorInfo  ;# global variable, contains last error msg
divide by zero
   while executing "expr { 1 / 0 }"
hcitcl>catch { expr { 1 / 0 } } errmsg ; echo $errmsg
devide by zero
hcitcl>catch {read_file /tmp/nonsense} errmsg ; echo $errmsg
Error: Couldn't open "/tmp/nonsense": No such file or directory
hcitcl>if { [catch { set data [ read_file /tmp/filename ]} ] } { 
       set data {}
       }  
</PRE>
</TD></TR>
</TABLE>


<h2> Various TclX procs </h2>
<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
-*</TD><TD><b>clock </b><BR>
Purpose: This function provides functionality related to either the current date/time
or the formatting of date/time strings.<BR>
Notes: Mostly used in the form of <b>clock seconds</b> (returns the number of seconds
since Jan. 1 1970) or <b>clock format $seconds -format <em>date_time_modifiers</em></b>. 
In previous Tcl versions these options were implemented as getclock and fmtclock. <br>
See the online documentation
of the <b>clock</b> function for valid modifiers to be used with fmtclock.<BR>
Examples:

<PRE>hcitcl>clock seconds
874930337
hcitcl>clock format [clock seconds] -format %Y%H%m
19981012
hcitcl># Yesterday's date: (current time minus 24*60*60 seconds)
hcitcl>clock format [expr {[clock seconds] -86400}] -format %m/%d/%Y
10/11/1998
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>ctype  </b><BR>
Purpose: This function either provides information about characters or strings 
or transforms them. The name ctype is derived from 'check-type'.<BR>
Notes: This function is often used either to tranform an ordinal value into
a character or vice versa or to to check whether a (sub)string contains characters
of a particular character class. <br>
Notes: See the online help for a listing of all valid character classes. <br>
Examples:

<PRE>hcitcl>ctype digit 123x
0
hcitcl>ctype alnum 123x
1
hcitcl>ctype ord x 
89
# returns the ordinal value of the character (89) as it is defined using the system encoding.
# See <a href="m54.htm">Module 54: Character Encoding</a> for details.
hcitcl>ctype char 89
x
# returns the character ("x") as defined by the system encoding based on the specified oridinal.
# See <a href="m54.htm">Module 54: Character Encoding</a> for details.
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>cequal </b><BR>
Purpose: This function compares characters and/or strings.<BR>
Notes: Recommended instead of "==" when comparing strings. <BR>
Examples:

<PRE>hcitcl>set a "27" ; if { [cequal $a "27"] } { echo "a equals 27!" }
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
-</TD><TD><b>format formatSpec string ?string..? </b><BR>
Purpose: This function formats a string according to a specific
displayformat. This function is the Tcl equivalent of the
<em>printf</em> function in C.<BR>
Examples:

<PRE>hcitcl>set etb [format %c 0x0a]
hcitcl>set name "Smith, P."
hcitcl>echo [ format "Name: %-25s #" $name ]
Name: Smith, P.                #
hcitcl>set checksum [ format "$02X" 27 ] ; echo $checksum
1B
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>lassign list varName ?varName..? </b><BR>
Purpose: This function assigns the respecitive values in a list to 
a series of variables on a one to one basis.<BR>
Notes: Often used in Code-Fragment procedures. 
<em>lassign xlateInVals var1 var2 ..</em>.<BR>
Examples:

<PRE>hcitcl>set l {one two three four}
hcitcl>lassign $l a b c ; echo $a $b $c
one two three
hcitcl>lassign $l a b c d e ; echo $e
{}
hcitcl>lassign {100 {ORDER {AMOUNT 100} {O# 23}} } ind ol ; echo $ol
ORDER {AMOUNT 100} {O# 23}
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
**</TD><TD><b>foreach varName list </b><BR>
Purpose: This function iterates over all elements in a list
and assigns the respective elements to the variable with varName
within each respective iteration.<BR>
Examples:

<PRE>hcitcl>set l {one two three four}
hcitcl>foreach el $l { echo "el = $el" }
el = one
el = two
el = three
el = four
hcitcl>set l {7 2 9}
hcitcl>foreach el $l { lappend l2 [expr {$el + 3}] } ; echo $l2
10 5 12
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
*-</TD><TD><b>tbllookup ?-side side? table value</b><BR>
Purpose: This function returns the value to which the <em>value</em>
parameter is mapped in the table <em>table</em>.<BR>
Notes: This procedure is an Quovadx extension and is used to map values using a table
created with the aid of the Lookup Table Configurator GUI tool.<BR>
Examples:

<PRE>hcitcl>tbllookup sex_code F
2
hcitcl>tbllookup -side systemb sex_code 1
M
</PRE>
</TD></TR>

</TABLE>

<P>
Copyright 2002 Health-Comm GmbH [60][40][55] 
</BODY>
</HTML>
