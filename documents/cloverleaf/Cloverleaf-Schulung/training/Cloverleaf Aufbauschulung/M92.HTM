<HTML>
<HEAD>
        <TITLE>Integrator Level II Training</TITLE><LINK href="training.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>


<h1>
<img src="images/hie_box.gif" align="middle" hspace=7> 
 Integrator - Level II Training </H1>

<h1> Module 92: HTTP Protocol Driver</h1>




The HTTP protocol driver (available in the Integrator versions 3.8 and above) can be compared to a
UPoC driver and is among the most flexible protocol driver options supported by the
engine.
The 'HTTP-Client driver' is one of the standard protocol types
that can be selected in the Network Configurator.
The functionality of the HTTP-Client protocol driver is based on 1 TPS-procedure that will be used 
both to 'PUT/POST' (deliver) a message and/or to 'GET' (retrieve) a message.

<p>
<TABLE>
<TR><TD valign="top"  bgcolor=#999999>
&nbsp;&nbsp;</TD><TD><B>encode string</B><BR>
Purpose: This function returns a base64 encoded version of the supplied string. Typically used to encode
a message and store the encoded vesrion into the entity-body of the HTTP request.<BR>
Examples:

<PRE>hcitcl>encode Hello
SGVsbG8=
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
&nbsp;&nbsp;</TD><TD><B>decode base64string</B><BR>
Purpose: This function returns a decoded version of the supplied base64 encoded string. Typically used to decode
(part of) the entity-body returned by the HTTP request.
Note that ASCII null characters embedded in the base64 string will result in the termination of the resulting string.<BR>
Examples:

<PRE>hcitcl>decode SGVsbG8=
Hello
</PRE>
</TD></TR>

<TR><TD valign="top"  bgcolor=#999999>
&nbsp;&nbsp;</TD><TD><B>httpget {{URL url} ?{HEADERS headerList}? ?{AUTH authList}? ?{HTTPS httpsList}? 
<br>&nbsp;&nbsp;&nbsp;?{PROXY ?{USER username}? ?{PASS password}? ?{HOST proxyhost}? ?{PORT proxyPort}?}? }</B><BR>
<B>httppost {{URL url} {DATA data} ?{HEADERS headerList}? ?{AUTH authList}? ?{HTTPS httpsList}?
<br>&nbsp;&nbsp;&nbsp;?{PROXY ?{USER username}? ?{PASS password}? ?{HOST proxyhost}? ?{PORT proxyPort}?}? }</B><BR>
<B>httpput {{URL url} {DATA data} ?{HEADERS headerList}? ?{AUTH authList}? ?{HTTPS httpsList}?
<br>&nbsp;&nbsp;&nbsp;?{PROXY ?{USER username}? ?{PASS password}? ?{HOST proxyhost}? ?{PORT proxyPort}?}? }</B><BR>
Purpose: These functions retrieve/transfer the data specified by/to the URL using the specified HTTP GET/POST or PUT method.  
See the Reference Guide for a detailed description of these procedures and their parameters.<BR>
Returns a keyed list with the following keys: 
<UL><LI>STATUS: a keyed list of status elements; e.g. {Version HTTP/1.0} {Code 200} {Desc OK}</LI>
<LI>HEADERS: a keyed list of HTTP headers; </LI>
<LI>BODY: a string containing the entity-body contained in the HTTP response (e.g. the requested data in case of a GET);</LI>
</UL>
</TD></TR>


</TABLE>

<p>
The HTTP protocol is defined in RFC 2068 (HTTP version 1.1) and RFC 1945 (version 1.0). These definitions include a description
of all standard headers and result codes. <br>
Please note: as defined by RFC 2068, all applications that do not support persistent connections MUST include the
close connection option in every message. Integrator doesn't support persistent connections. 
<br>Therefore <b>one of the headers MUST be {Connection: close}</b>. 


<h2>The HTTP Query TPS</h2>

The following procedure is an example of a non-specilized generic HTTP-Client procedure.
The 'Time' mode is typically used to periodically GET a specfied URL and return the results 
as an Inbound Data message into the engine. 
The 'Run' mode will typically be used to PUT or POST data to an URL. This may be a simple upload
or part of a query/response mechanism using mechanisms such as CGI or SOAP.

<PRE>########################################################################################
# Name:      httpClientQuery
# Purpose:   Basic Message-driven HTTP query
# UPoC type: HTTP-QUERY TPS
# Args:      tps keyedlist containing the following keys:
#            MODE    uses time-mode for time-driven queries
#                    uses run-mode for message-driven queries
#                    start mode always used for storing NetConfig vals
#            MSGID   message handle
#            ARGS    user-supplied arguments: 
#                        MSGUSE - used in Run mode only
#                              URL  (default for GET) 
#                                   content of message will be used as URL
#                              DATA (default for POST and PUT)
#                                   content of message wil be used as DATA
#                                   when using POST or PUT option
#                              CGI  content of message will be used as 
#                                   paramlist for CGI script, URL of CGI script
#                                   to be defined in GUI.
#

proc httpClientQuery { args } {
    global cfgs

    keylget args MODE mode       
    keylget args ARGS uargs
    set dispList {}

    switch -exact -- $mode {
        start {
            # grab and store CFGS values for run/time mode -- 
            # CFGS are only available in start mode.
            keylget args CFGS cfgs
            return ""
        }

        time {
            # fetch the URL using the specified method
            # the URL used will be taken from NetConfig
            keylget cfgs METHOD method
            switch -exact -- $method {
                PUT { set res [httpput $cfgs] }
                POST { set res [httppost $cfgs] }
                default { set res [httpget $cfgs] }
            }

            # parse out the response
            set status [keylget res "STATUS"]
            set statCode [lindex $status 1]
            set body [keylget res "BODY"]
            set headers [keylget res "HEADERS"]  
            keylget cfgs URL url

            # a status code lower than 300 indicates success.
            # any error responses that contain xml in their body will be forwarded 
            # into the engine as well.
            if {($statCode &lt; 300) || [regexp {\&lt;\?xml} $body] } {
                # if OK, place msg into IB queue
                # This UPoC is outbound, so use OVER to generate IB msg
                set outMsg [msgcreate -recover -type data $body]
                # attach URL to response message
                keylset usrdata URL $url
                msgmetaset $outMsg USERDATA $usrdata
                lappend dispList "OVER $outMsg"
            } else {
                # otherwise, report the error
                echo "(httpClientQuery/Time [crange [fmtclock [getclock]] 0 18]) Error fetching URL $url: $status"
            }
        }

        run {
            # extract URL from inbound message
            keylget args MSGID inMsg

            # determine the manner in which the message content is to be used
            keylget cfgs METHOD method
            if [cequal $method GET] {
                 set msguse URL 
            } else {
                set msguse DATA
            }
            keylget uargs MSGUSE msguse

            # update local var 'val' using user params and msg content
            set val ${cfgs}
            switch $msguse {
                DATA {
                    keylset val DATA [msgget $inMsg]
                }
                CGI {
                    keylget val URL url
                    append url "[msgget $inMsg]"
                    keylset val URL $url
                }
                default {
                    set url [string trim [msgget $inMsg]]
                    keylset val URL $url           
                }
            }

            # fetch the URL using the specified method
            switch -exact -- $method {
                PUT { set res [httpput $val] }
                POST { set res [httppost $val] }
                default { set res [httpget $val] }
            }

            # parse out the response
            set status [keylget res "STATUS"]
            set statCode [lindex $status 1]
            set body [keylget res "BODY"]
            set headers [keylget res "HEADERS"]  
            keylget val URL url

            # a status code lower than 300 indicates success.
            # any error responses that contain xml in their body will be forwarded 
            # into the engine as well.
            if {($statCode &lt; 300) || [regexp {\&lt;\?xml} $body] } {
                # if OK, place msg into IB queue
                set outMsg [msgcreate -recover -type data $body]
                lappend dispList "KILL $inMsg"
                # attach URL to response message
                keylset usrdata URL $url
                msgmetaset $outMsg USERDATA $usrdata
                lappend dispList "OVER $outMsg"
            } else {
                # otherwise, report the error and send orig msg to error DB
                set msg "(httpClientQuery/Run) Error fetching URL $url: $status"
                echo $msg
                msgmetaset $inMsg USERDATA $msg
                lappend dispList "ERROR $inMsg"
            }
        }

        shutdown {
        }

        default {
                error "Procedure httpClientQuery used in undefined mode $mode."
        }
    }
return $dispList
}
</PRE>

Note: additional HTTP-Query examples can be found in the $HCIROOT/contrib/http_stds.tcl file. The procedures listed in that
file are documented in the Reference Guide. 

<p>
The gc_httpClientQuery procedure also contains support for DRIVERCTL metadata (those parts of the code
have been removed from the above example for simplicity's sake).
See also <a href="m95.htm#http">Module 95: DRIVERCTL metadata</a>


<p>
Copyright 2002 Health-Comm GmbH
</BODY>
</HTML>
